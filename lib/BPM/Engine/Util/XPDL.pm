package BPM::Engine::Util::XPDL;
BEGIN {
    $BPM::Engine::Util::XPDL::VERSION   = '0.001';
    $BPM::Engine::Util::XPDL::AUTHORITY = 'cpan:SITETECH';
    }

use strict;
use warnings;
use File::Spec ();
use File::ShareDir ();
use File::Basename ();
use XML::LibXML;
use XML::LibXML::XPathContext;
use BPM::XPDL;
use BPM::Engine::Types qw/Exception/;
use BPM::Engine::Exceptions qw/throw_model throw_install throw_param/;

use parent qw/Exporter/;
our @EXPORT = qw/xml_doc xpdl_doc xpdl_hash/;

sub xml_doc {
    my $arg = shift or throw_param error => "Empty file or string";

    my $parser = XML::LibXML->new;
    my $doc = undef;

    eval {
        if(ref($arg) eq 'SCALAR') {
            $doc = eval { $parser->parse_string($$arg); };
            die "Invalid XML: $@" if $@;
            }
        elsif(!ref($arg)) {
            throw_param error => "Invalid XML: Empty file name" unless $arg;
            unless(-f $arg) {
                $arg = File::Basename::fileparse($arg);
                throw_param error => "File '$arg' not found";
                }
            $doc = eval { $parser->parse_file($arg); };
            die "Invalid XML: $@" if $@;
            }
        else {
            throw_param error => "Invalid argument ref '$arg'";
            }
        };
    if(my $err = $@) {
        $err->rethrow() if(is_Exception($err));
        throw_model error => $err;
        }

    return $doc;
    }

sub xpdl_doc {
    my $doc = shift;

    $doc = xml_doc($doc) unless(ref($doc) eq 'XML::LibXML::Document');

    eval {
        # get XPDL version from xml
        my @nodes = $doc->documentElement->getElementsByTagName('XPDLVersion');
        die "XPDLVersion not defined" unless $nodes[0];
        my $v = $nodes[0]->textContent;
        $v =~ s/(^\s*|\s*$)//g;
        die "XPDL version not set" unless $v;
        die "Unsupported XPDL version $v" 
            unless(grep { $v == $_ } qw/1.0 2.0 2.1 2.2/);
        $v =~ s/\./_/;

        # clean up modeler-proprietary elements and attributes
        my @vnodes = $doc->documentElement->getElementsByTagName('Vendor');
        if($vnodes[0] && $vnodes[0]->textContent =~ /BizAgi/) {
            _clean_bizagi_xml($doc);
            }

        # validate against schema since BPM::XPDL's validation isn't informative
        my $schema_file = _xpdl_spec($v);
        my $schema = XML::LibXML::Schema->new(location => $schema_file);

        eval { $schema->validate($doc); };
        
        if(my $err = $@) {
            if(ref($err) eq 'XML::LibXML::Error') {
                die "Non-conformant XML: " . $err->message .
                 " in file " . File::Basename::fileparse($err->file) .
                 " (schema " . File::Basename::fileparse($schema_file) . ")" .
                 ($err->line ? ' line ' . $err->line : '');
                #die $@ if $@->level > 2;
                }
            else {
                die $@;
                }
            }
        };
    
    if(my $err = $@) {
        $err->rethrow() if(is_Exception($err));
        throw_model error => $err;
        }

    return $doc;
    }

sub xpdl_hash {
    my $arg = shift;

    my $doc  = xpdl_doc($arg);
    my $xpdl;
    eval {
        $xpdl = (BPM::XPDL->from($doc))[1];
        };
    if($@) {
        die "BPM::XPDL error: $@";
        }

    return $xpdl;
    }

# remove non-conformant elements and attributes generated by BizAgi modeler
sub _clean_bizagi_xml {
    my $xmldoc = shift;

    _remove_attributes($xmldoc, 'ConnectorGraphicsInfo', 'FromPort', 'ToPort');
    _remove_attributes($xmldoc, 'Package', 'OnlyOneProcess');

    # Association is missing a required Object element before
    # ConnectorGraphicsInfos, and may contain non-valid ExtendedAttributes.
    # Other elements are proprietary to BizAgi

    my $xc = XML::LibXML::XPathContext->new($xmldoc);
    $xc->registerNs('xpdl', 'http://www.wfmc.org/2008/XPDL2.1');

    my @els = (
        'IsForCompensationSpecified',
        'RequiredForStartSpecified',
        'ProducedAtCompletionSpecified',
        'Associations/Association/ConnectorGraphicsInfos',
        'Associations/Association/ExtendedAttributes',
        'Artifacts/Artifact/Documentation'
        );
    foreach my $tag(@els) {
        _remove_elements($xmldoc, $xc, $tag);
        }
    }

sub _remove_attributes {
    my ($xmldoc, $tag, @attr) = @_;

    my @nodes = $xmldoc->getElementsByTagName($tag);
    foreach my $node(@nodes) {
        foreach(@attr) { 
            $node->removeAttribute($_);
            }
        }
    }

sub _remove_elements {
    my ($xmldoc, $xc, $tag) = @_;
    my (@nodes) = ();
    if($tag =~ /\//) {
        my $xpath = '//xpdl:Package/xpdl:' . join('/xpdl:', split('\/', $tag));
        @nodes = $xc->findnodes($xpath);
        }
    else {
        @nodes = $xmldoc->getElementsByTagName($tag);
        }
    foreach my $node(@nodes) {
        my $parent = $node->parentNode;
        $parent->removeChild($node);
        }
    }

sub _xpdl_spec {
    my $version = shift;

    my $fname = "XPDL_$version.xsd";
    my $file;

    eval {
        # suppress warnings from File::ShareDir feeding uninitialized dir to 
        # File::Spec's catfile() when dist not installed.
        # no warnings 'uninitialized' doesn't work here.
        local $SIG{__WARN__} = sub {};
        $file = File::ShareDir::dist_file('BPM-Engine', "schemas/$fname");
        };

    if($@ =~ /Failed to find shared file/) {
        my ($volume, $directory, $name) = File::Spec->splitpath(__FILE__);
        $file = File::Spec->catpath(
            $volume, $directory, "../../../../share/schemas/$fname"
            );
        unless(-e $file) {
            throw_install error => "Schema '$fname' not found in shared dirs";
            }
        unless ( -r $file) {
            throw_install 
                error => "Schema '$fname' cannot be read, no read permissions";
            }
        }
    elsif($@) {
        throw_install error => "Schema '$fname' not found in shared dirs: $@";
        }
    
    return $file;
    }

1;
__END__